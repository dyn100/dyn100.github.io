<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>链表变体与约瑟夫环</title>
    <link href="/2020/03/10/linklist2/"/>
    <url>/2020/03/10/linklist2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这一章节如果涉及到算法其实还是挺多的，但是基本知识基本上跟单链表没啥区别。</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>了解循环链表，双向链表（这一部分真的不想贴代码了，跟单链表感觉没啥区别，都是操作指针。</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>没啥特别的，单链表尾指针指向头节点。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>插入：<br>和单链表一样，需要辅助链表定位插入的前后结点，操作基本与单链表相同，只是多调整一个前指针而已。</p><p>删除：<br>参考单链表删除，调整结点指针，释放目标空间。</p><h2 id="小游戏：约瑟夫环"><a href="#小游戏：约瑟夫环" class="headerlink" title="小游戏：约瑟夫环"></a>小游戏：约瑟夫环</h2><p>下面玩个有意思的：约瑟夫和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，自杀方法是，大家轮流报数，报到7的人自杀，直到所有人死去。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。</p><p>事实上，我们可以通过循环链表解决这个问题。</p><blockquote><p>tips：本期初始化函数已经开始使用new，但仍然采用C语言的参数传递模式，在下一期开始将完全使用C++引用模式以简化程序。同时，cout，cin函数及C++头文件已经引入，用于简化程序。</p></blockquote><p>完整源码：</p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;using namespace std;typedef struct node { int data; node* next;}node, * linklist;//创建循环链表linklist create() { node* p; p = new node; p-&gt;next = NULL; p-&gt;data = 41; for (int i = 1; i &lt; 41; i++) {  node* q = new node;  q-&gt;next = p-&gt;next;  q-&gt;data = 41 - i;  p-&gt;next = q;  if (i == 1) {   q-&gt;next = p;  } } return p;}int main() { node* joseph = new node; joseph = create(); node* t = joseph; node* tmp = joseph; node* tmp2; int num = 0; int count = 0; //开始递进 for (int i = 0; ; i++) {  tmp2 = tmp;  tmp = tmp-&gt;next;  num = num + 1;  //到7删除  if (num == 7) {   tmp2-&gt;next = tmp-&gt;next;   free(tmp);   tmp = tmp2-&gt;next;   num = 1;   count++;  }  //剩两人跳出  if (count == 39) {   break;  } } //结果输出 cout &lt;&lt; tmp-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; tmp-&gt;next-&gt;data;} </code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>上面的代码可能并不是很简单，但符合我的编写习惯，欢迎大家给我提意见。<br>约瑟夫环事实上可以使用递归求解，当然理解难度较大，有兴趣的同学可以查一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表</title>
    <link href="/2020/03/10/linklist/"/>
    <url>/2020/03/10/linklist/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本栏目是我新博客的第一个栏目，写这个栏目的原因是这学期有数据结构课程，一方面让自己复习一下，另一方面希望能帮助到有需要的同学。本栏目使用语言为C++，但由于课程要求为类C，且大部分同学没有C++经验，因此大部分语言结构基于C语言。</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>单链表的初始化，建立，插入，查找，删除</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>单链表的结构很简单：仅由数据和指针组成</p><pre><code class="C++">typedef struct Node{    int data;              //单链表中的数据域 ，本示例用的int型    struct Node *next;          //单链表的指针域 }Node,*LinkedList;</code></pre><h3 id="初始化链表过程："><a href="#初始化链表过程：" class="headerlink" title="初始化链表过程："></a>初始化链表过程：</h3><pre><code class="C++">LinkedList LinkedListInit(){    Node *L;    L = (Node *)malloc(sizeof(Node));   //申请结点空间     if(L == NULL)                       //判断是否有足够的内存空间         printf(&quot;申请内存空间失败/n&quot;);    L-&gt;next = NULL;                  //将next设置为NULL,初始长度为0的单链表 }</code></pre><h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><p>建立链表分为头插法和尾插法</p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>头插法，就是每一次插入都是从链表头插入，实现也比较简单：</p><pre><code class="C++">LinkedList LinkedListCreatH(){    Node *L;    L = (Node *)malloc(sizeof(Node));   //申请头结点空间    L-&gt;next = NULL;                      //初始化一个空链表    int x;                         //x为链表数据域中的数据    while(scanf(&quot;%d&quot;,&amp;x) != EOF)    {        Node *p;        p = (Node *)malloc(sizeof(Node));   //申请新的结点         p-&gt;data = x;                     //结点数据域赋值         p-&gt;next = L-&gt;next;                           L-&gt;next = p;     }    return L; } </code></pre><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><p>每一次从链表尾部插入，这一过程通常需要借助一个辅助链表，简要描述此过程：</p><p>1 辅助链表r和原始链表L重合</p><p>2 创建P，给P赋值</p><p>3 将原始链表空指针指向p，将r指向尾结点</p><pre><code class="C++">LinkedList LinkedListCreatT(){    Node *L;    L = (Node *)malloc(sizeof(Node));   //申请头结点空间    L-&gt;next = NULL;                  //初始化一个空链表    Node *r;    r = L;                          //r始终指向终端结点，开始时指向头结点     int x;                         //x为链表数据域中的数据    while(scanf(&quot;%d&quot;,&amp;x) != EOF)    {        Node *p;        p = (Node *)malloc(sizeof(Node));   //申请新的结点         p-&gt;data = x;                     //结点数据域赋值         r-&gt;next = p;                 //将结点插入到表头L--&gt;|1|--&gt;|2|--&gt;NULL         r = p;     }    r-&gt;next = NULL;     return L;   }  </code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>了解了建立链表，插入就简单了，例如在i位置插入x</p><pre><code class="C++">LinkedList LinkedListInsert(LinkedList L,int i,int x){    Node *pre;                      //pre为前驱结点     pre = L;    int tempi = 0;    for (tempi = 1; tempi &lt; i; tempi++)        pre = pre-&gt;next;                 //查找第i个位置的前驱结点     Node *p;                                //插入的结点为p    p = (Node *)malloc(sizeof(Node));    p-&gt;data = x;     p-&gt;next = pre-&gt;next;    pre-&gt;next = p;    return L;                           }   </code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>对于删除一段链表，我们需要借助两个辅助链表分别指向被删除段和被删除段的前一段，然后让链表重新指过去就好了。</p><pre><code class="C++"> LinkedList LinkedListDelete(LinkedList L,ElemType x){    Node *p,*pre;                   //pre为前驱结点，p为查找的结点。     p = L-&gt;next;    while(p-&gt;data != x)              //查找值为x的元素     {           pre = p;         p = p-&gt;next;    }    pre-&gt;next = p-&gt;next;          //删除操作，将其前驱next指向其后继。     free(p);    return L;}   </code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>在之后的章节，我会使用new代替malloc函数，并使用一些很简单的C++语句，习惯问题，大家理解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界 MISC 新手村攻略</title>
    <link href="/2020/03/10/hello-world/"/>
    <url>/2020/03/10/hello-world/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作为一名逆向手，MISC之前看别人做一直感觉好玩但没碰过(此前一直羡慕队里的MISC手），真正做起来感觉这玩意还是挺烧脑的，脑洞不够的我着实玩不起/xk/xk</p></blockquote><p>题目地址： <a href="https://adworld.xctf.org.cn/task/task_list?type=misc&amp;number=1&amp;grade=0&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/task_list?type=misc&amp;number=1&amp;grade=0&amp;page=1</a></p><h2 id="this-is-flag"><a href="#this-is-flag" class="headerlink" title="this_is_flag"></a>this_is_flag</h2><p>签到题，flag题干直接给了</p><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p>题干中提到图片下面什么都没有，所以我们把图片移走就好了，flag在下面</p><p>这题大佬们似乎都用的PDF编辑器，我这种业余玩家是把PDF转成word来弄的，实现此功能有个靠谱的网站：<br><a href="https://app.xunjiepdf.com/pdf2word/" target="_blank" rel="noopener">https://app.xunjiepdf.com/pdf2word/</a></p><h2 id="give-you-flag"><a href="#give-you-flag" class="headerlink" title="give_you_flag"></a>give_you_flag</h2><p>动态图按贞分解发现了疑似二维码，但是这个二维码好像缺了点什么。。<br><img src="https://s2.ax1x.com/2020/03/10/8CjHe0.png" srcset="/img/loading.gif" alt="8CjHe0.png" border="0" /><br>拿个正常二维码对比一下，发现是少了三个角，修复之后如下：<br><a href="https://imgchr.com/i/8CvLnI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/10/8CvLnI.th.png" srcset="/img/loading.gif" alt="8CvLnI.png" border="0" /></a><br>扫描得flag</p><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p>与佛论禅编码，发现疑似base64，但是解不开，考虑到题干中有13，于是想到了rot13，rot13后再进行base64解码，推荐一个网站： <a href="http://ctf.ssleye.com/" target="_blank" rel="noopener">http://ctf.ssleye.com/</a> ，可以实现大部分简单编码、密码加解密。</p><p>flag{bdscjhbkzmnfrdhbvckijndskvbkjdsab}</p><h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><p>黑白图片，进行白为0黑为1的转换得到：01100110011011000110000101100111011110110100011001110101010011100101111101100111011010010100011001111101<br>二进制转字符串，仍然可以使用上面的网页完成</p><p>flag{FuN_giF}</p><h2 id="坚持60s"><a href="#坚持60s" class="headerlink" title="坚持60s"></a>坚持60s</h2><p>菜鸡终于看见一道属于自己的本职工作了（得以嘲讽队内MISC大佬们）<br>jar文件，jd-gui直接看源码就行<br><img src="https://s2.ax1x.com/2020/03/10/8CxhKs.png" srcset="/img/loading.gif" alt="8CxhKs.png" border="0" /></p><h2 id="掀桌子"><a href="#掀桌子" class="headerlink" title="掀桌子"></a>掀桌子</h2><p>一串16进制数，按ascii码分析，感觉这些数都太大了，突然发现每个数-0x80之后都在可见字符范围内，python脚本给上：</p><pre><code class="python">string = &quot;c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2&quot;flag = &#39;&#39;for i in range(0,len(string), 2):    s = &quot;0x&quot; + string[i] + string[i+1]    flag += chr(int(s, 16) - 0x80)print(flag)</code></pre><h2 id="ext3"><a href="#ext3" class="headerlink" title="ext3"></a>ext3</h2><p>linux映像文件，ubuntu导入映像，翻文件翻到flag（ls，cd，cat大法）</p><h2 id="stegano"><a href="#stegano" class="headerlink" title="stegano"></a>stegano</h2><p>用记事本打开看到一堆AB，疑似摩尔斯电码，转化发现flag</p><h2 id="base64stego"><a href="#base64stego" class="headerlink" title="base64stego"></a>base64stego</h2><p>涉及到base64隐写问题，看大佬分析吧<a href="https://blog.csdn.net/zz_Caleb/article/details/89298335" target="_blank" rel="noopener">https://blog.csdn.net/zz_Caleb/article/details/89298335</a></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>还有两道题没做，以后再补吧（又鸽了）。话说MISC确实很好玩，不过我也是菜，几道入门题玩了这么长时间。。。以后有时间还会继续玩的</p>]]></content>
    
    
    
    <tags>
      
      <tag>信息安全</tag>
      
      <tag>MISC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人简介</title>
    <link href="/2020/03/09/myself/"/>
    <url>/2020/03/09/myself/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是我的新博客，之前的博客因为一直没更就放弃了，这次希望能坚持做下去</p></blockquote><h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>一名末流985学校的菜鸡，计算机专业学生，软件开发爱好者，信息安全爱好者。</p><h2 id="准备写点什么"><a href="#准备写点什么" class="headerlink" title="准备写点什么"></a>准备写点什么</h2><p>程序开发、算法、CTF、以及一些奇怪的东西。</p><h2 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h2><p>准备先移植一下之前在各平台发的文章之类的，会不定期更一些数据结构和信息安全内容。</p><h2 id="单人博客？"><a href="#单人博客？" class="headerlink" title="单人博客？"></a>单人博客？</h2><p>会考虑让几个有想法的同学加入进来，做出一个优秀的IT博客，目前欢迎网络、软件开发、二进制、数学爱好者加入。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p>我的邮箱：<a href="mailto:dyn201885095@gmail.com">dyn201885095@gmail.com</a></p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>fun in everything</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
